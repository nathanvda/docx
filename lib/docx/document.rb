require 'docx/containers'
require 'docx/elements'
require 'nokogiri'
require 'zip'

module Docx
  # The Document class wraps around a docx file and provides methods to
  # interface with it.
  #
  #   # get a Docx::Document for a docx file in the local directory
  #   doc = Docx::Document.open("test.docx")
  #
  #   # get the text from the document
  #   puts doc.text
  #
  #   # do the same thing in a block
  #   Docx::Document.open("test.docx") do |d|
  #     puts d.text
  #   end
  class Document
    attr_reader :xml, :doc, :zip, :styles

    DOCUMENT_PATHS = {
      styles:    "word/styles.xml",
      rels:      "word/_rels/document.xml.rels",
      headers:   "word/header*.xml",
      footers:   "word/footer*.xml",
      numbering: "word/numbering.xml"
    }

    def initialize(path_or_io, options = {})
      @replace = {}

      # if path-or_io is string && does not contain a null byte
      if (path_or_io.instance_of?(String) && !/\u0000/.match?(path_or_io))
        @zip = Zip::File.open(path_or_io)
      else
        @zip = Zip::File.open_buffer(path_or_io)
      end

      document = @zip.glob('word/document*.xml').first
      raise Errno::ENOENT if document.nil?

      @document_xml = document.get_input_stream.read
      @doc = Nokogiri::XML(@document_xml)

      load_styles
      load_headers
      load_footers
      load_numbering

      yield(self) if block_given?
    ensure
      @zip.close
    end

    # This stores the current global document properties, for now
    def document_properties
      {
        font_size: font_size,
        hyperlinks: hyperlinks
      }
    end

    # With no associated block, Docx::Document.open is a synonym for Docx::Document.new. If the optional code block is given, it will be passed the opened +docx+ file as an argument and the Docx::Document oject will automatically be closed when the block terminates. The values of the block will be returned from Docx::Document.open.
    # call-seq:
    #   open(filepath) => file
    #   open(filepath) {|file| block } => obj
    def self.open(path, &block)
      new(path, &block)
    end

    def paragraphs
      @doc.xpath('//w:document//w:body/w:p').map { |p_node| parse_paragraph_from p_node }
    end

    def bookmarks
      bkmrks_hsh = {}
      bkmrks_ary = @doc.xpath('//w:bookmarkStart').map { |b_node| parse_bookmark_from b_node }
      bkmrks_ary += @headers.values.map { |xml_doc| xml_doc.xpath('//w:bookmarkStart').map { |b_node| parse_bookmark_from b_node } }.flatten
      bkmrks_ary += @footers.values.map { |xml_doc| xml_doc.xpath('//w:bookmarkStart').map { |b_node| parse_bookmark_from b_node } }.flatten
      # auto-generated by office 2010
      bkmrks_ary.reject! { |b| b.name == '_GoBack' }
      bkmrks_ary.each { |b| bkmrks_hsh[b.name] = b }

      bkmrks_hsh
    end

    def tables
      @doc.xpath('//w:document//w:body//w:tbl').map { |t_node| parse_table_from t_node }
    end

    # Some documents have this set, others don't.
    # Values are returned as half-points, so to get points, that's why it's divided by 2.
    def font_size
      return nil unless @styles

      size_tag = @styles.xpath('//w:docDefaults//w:rPrDefault//w:rPr//w:sz').first
      size_tag ? size_tag.attributes['val'].value.to_i / 2 : nil
    end

    # Hyperlink targets are extracted from the document.xml.rels file
    def hyperlinks
      hyperlink_relationships.each_with_object({}) do |rel, hash|
        hash[rel.attributes['Id'].value] = rel.attributes['Target'].value
      end 
    end

    def hyperlink_relationships
      @rels.xpath("//xmlns:Relationship[contains(@Type,'hyperlink')]")
    end    

    ##
    # *Deprecated*
    #
    # Iterates over paragraphs within document
    # call-seq:
    #   each_paragraph => Enumerator
    def each_paragraph
      paragraphs.each { |p| yield(p) }
    end

    # call-seq:
    #   to_s -> string
    def to_s
      paragraphs.map(&:to_s).join("\n")
    end

    # Output entire document as a String HTML fragment
    def to_html
      paragraphs.map(&:to_html).join("\n")
    end

    # Save document to provided path
    # call-seq:
    #   save(filepath) => void
    def save(path)
      update
      Zip::OutputStream.open(path) do |out|
        zip.each do |entry|
          next unless entry.file?

          out.put_next_entry(entry.name)

          if @replace[entry.name]
            out.write(@replace[entry.name])
          else
            out.write(zip.read(entry.name))
          end
        end
      end
      zip.close
    end

    # Output entire document as a StringIO object
    def stream
      update
      stream = Zip::OutputStream.write_buffer do |out|
        zip.each do |entry|
          next unless entry.file?

          out.put_next_entry(entry.name)

          if @replace[entry.name]
            out.write(@replace[entry.name])
          else
            out.write(zip.read(entry.name))
          end
        end
      end

      stream.rewind
      stream
    end

    alias text to_s

    def replace_entry(entry_path, file_contents)
      @replace[entry_path] = file_contents
    end

    private

    def load_styles
      extract_single_document_from_path :styles
      extract_single_document_from_path :rels
    end

    def load_headers
      extract_multiple_documents_from_globbed_path :headers
    end

    def load_footers
      extract_multiple_documents_from_globbed_path :footers
    end

    def load_numbering
      extract_single_document_from_path :numbering
    end

    def extract_single_document_from_path(attr_name)
      path = DOCUMENT_PATHS[attr_name]
      if @zip.find_entry(path)
        xml_doc = @zip.read(path)
        self.instance_variable_set(:"@#{attr_name}", Nokogiri::XML(xml_doc))
      end
    end

    def extract_multiple_documents_from_globbed_path(attr_name)
      glob_path = DOCUMENT_PATHS[attr_name]
      files = @zip.glob(glob_path).map { |h| h.name }
      filename_and_contents_pairs = files.map do |file|
        simple_file_name = file.sub(/^word\//, "").sub(/\.xml$/, "")
        [simple_file_name, Nokogiri::XML(@zip.read(file))]
      end
      hash = Hash[filename_and_contents_pairs]
      self.instance_variable_set(:"@#{attr_name}", hash)
    end

    #--
    # TODO: Flesh this out to be compatible with other files
    # TODO: Method to set flag on files that have been edited, probably by inserting something at the
    # end of methods that make edits?
    # TODO: save document.xml or document2.xml ?
    #++
    def update
      replace_entry 'word/document.xml', doc.serialize(save_with: 0)
      update_multiple_documents :headers
      update_multiple_documents :footers
      update_single_document :numbering
      # also save styles? / rels?
    end

    def update_multiple_documents(attr_name)
      self.instance_variable_get("@#{attr_name}").each do |simple_file_name, contents|
        replace_entry("word/#{simple_file_name}.xml", contents.serialize(:save_with => 0))
      end
    end

    def update_single_document(attr_name)
      path = DOCUMENT_PATHS[attr_name]
      xml_document = self.instance_variable_get("@#{attr_name}")
      replace_entry path, xml_document.serialize(:save_with => 0) if xml_document
    end


    # generate Elements::Containers::Paragraph from paragraph XML node
    def parse_paragraph_from(p_node)
      Elements::Containers::Paragraph.new(p_node, document_properties)
    end

    # generate Elements::Bookmark from bookmark XML node
    def parse_bookmark_from(b_node)
      Elements::Bookmark.new(b_node)
    end

    def parse_table_from(t_node)
      Elements::Containers::Table.new(t_node)
    end
  end
end
